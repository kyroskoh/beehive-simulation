<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beehive Construction Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        
        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        #canvasContainer {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        canvas {
            display: block;
            border: 2px solid #ddd;
            border-radius: 10px;
        }
        
        #controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 800px;
            max-width: 95%;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .author {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            margin-top: -10px;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 250px;
            line-height: 1.5;
        }
        
        #tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #FFD700;
        }
        
        #tooltip .tooltip-item {
            margin: 3px 0;
        }
        
        .tracked-bee {
            box-shadow: 0 0 15px 3px rgba(255, 215, 0, 0.8);
        }
        
        .tracked-cell {
            box-shadow: 0 0 20px 5px rgba(100, 150, 255, 0.8);
        }
        
        .tips {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }
        
        .tips-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .tips-list {
            font-size: 13px;
            color: #555;
            line-height: 1.8;
        }
        
        .tips-list li {
            margin-left: 20px;
            margin-bottom: 4px;
        }
        
        .tip-icon {
            color: #667eea;
            margin-right: 5px;
        }
        
        .chart-container {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }
        
        .chart-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .mini-chart {
            height: 80px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            position: relative;
            margin-bottom: 15px;
        }
        
        .chart-line {
            stroke-width: 2;
            fill: none;
        }
        
        .chart-line-total {
            stroke: #667eea;
        }
        
        .chart-line-honey {
            stroke: #FFD700;
        }
        
        .chart-legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .chart-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .bee-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .bee-forager {
            background: #FFD700;
            color: #333;
        }
        
        .bee-builder {
            background: #FFA500;
            color: #333;
        }
        
        .bee-nurse {
            background: #90EE90;
            color: #333;
        }
        
        #trackedBeeStats {
            position: fixed;
            right: 20px;
            top: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            min-width: 250px;
            max-width: 300px;
            display: none;
            z-index: 100;
        }
        
        #trackedBeeStats.visible {
            display: block;
        }
        
        #trackedCellStats {
            position: fixed;
            left: 20px;
            top: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            min-width: 250px;
            max-width: 300px;
            display: none;
            z-index: 100;
        }
        
        #trackedCellStats.visible {
            display: block;
        }
        
        .tracked-bee-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        .tracked-bee-title {
            font-weight: bold;
            font-size: 16px;
            color: #333;
        }
        
        .tracked-bee-stats-grid {
            display: grid;
            gap: 12px;
        }
        
        .tracked-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .tracked-stat-label {
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }
        
        .tracked-stat-value {
            font-size: 14px;
            color: #333;
            font-weight: bold;
        }
        
        .tracked-stat-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .tracked-stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
        
        .tracked-stat-bar-fill.honey {
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }
        
        .tracked-stat-bar-fill.efficiency {
            background: linear-gradient(90deg, #90EE90, #32CD32);
        }
        
        .no-bee-tracked {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }
    </style>
</head>
<body>
    <h1>üêù Beehive Construction Simulation</h1>
    <div class="author">Created by Kyros Koh</div>
    
    <div id="canvasContainer">
        <canvas id="beehiveCanvas" width="800" height="600"></canvas>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="trackedCellStats">
        <div class="tracked-bee-header">
            <span class="tracked-bee-title">üìä Tracked Cell Stats</span>
        </div>
        <div id="trackedCellContent">
            <div class="no-bee-tracked">No cell tracked<br>Click a cell to track it</div>
        </div>
    </div>
    
    <div id="trackedBeeStats">
        <div class="tracked-bee-header">
            <span class="tracked-bee-title">üìä Tracked Bee Stats</span>
        </div>
        <div id="trackedBeeContent">
            <div class="no-bee-tracked">No bee tracked<br>Click a bee to track it</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label for="colonySize">Colony Size: <span id="colonySizeValue">10</span> bees</label>
            <div class="slider-container">
                <input type="range" id="colonySize" min="5" max="50" value="10" step="1">
            </div>
        </div>
        
        <div class="control-group">
            <label for="resourceAvailability">Resource Availability: <span id="resourceValue">50</span>%</label>
            <div class="slider-container">
                <input type="range" id="resourceAvailability" min="10" max="100" value="50" step="5">
            </div>
        </div>
        
        <div class="control-group">
            <label for="hiveSize">Hive Size: <span id="hiveSizeValue">8</span> rings</label>
            <div class="slider-container">
                <input type="range" id="hiveSize" min="3" max="15" value="8" step="1">
            </div>
        </div>
        
        <div class="control-group">
            <label for="simulationSpeed">Simulation Speed: <span id="speedValue">0.50</span>x</label>
            <div class="slider-container">
                <input type="range" id="simulationSpeed" min="0.25" max="4" value="0.5" step="0.25">
            </div>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="beeNamingEnabled" checked>
                Enable Bee Naming
            </label>
            <div style="margin-top: 8px;">
                <label for="beeNamingFormat" style="font-size: 13px; color: #666;">Naming Format:</label>
                <select id="beeNamingFormat" style="margin-top: 5px; padding: 5px 10px; border-radius: 5px; border: 1px solid #ddd; width: 100%;">
                    <option value="mixed">Mixed (Numbers & Names)</option>
                    <option value="number">Numbers Only (e.g., forager#001)</option>
                    <option value="name">Names Only (e.g., forager-ben)</option>
                </select>
            </div>
        </div>
        
        <div class="button-group">
            <button id="resetBtn">Reset Simulation</button>
            <button id="pauseBtn">Pause</button>
            <button id="clearTrackingBtn">Clear Tracking</button>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #fff4e6;"></div>
                <span>Empty Cell</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Honey Stored</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFA500;"></div>
                <span>Full Honey</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #E8E8E8;"></div>
                <span>Brood Cell</span>
            </div>
        </div>
        
        <div class="legend" style="margin-top: 10px;">
            <div class="legend-item">
                <div class="legend-color" style="background: #FFFFC8;"></div>
                <span>Egg</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFC896;"></div>
                <span>Larva</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #C8C8FF;"></div>
                <span>Pupa</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF69B4; border: 2px solid #FFD700;"></div>
                <span>Queen Bee</span>
            </div>
        </div>
        
        <div class="legend" style="margin-top: 10px;">
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700; border: 1px solid #333;"></div>
                <span>Forager</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF8C00; border: 1px solid #333;"></div>
                <span>Builder</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #90EE90; border: 1px solid #333;"></div>
                <span>Nurse</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #87CEEB; border: 1px solid #333;"></div>
                <span>Scout</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B4513; border: 1px solid #333;"></div>
                <span>Drone</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Total Cells</div>
                <div class="stat-value" id="totalCells">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Honey Cells</div>
                <div class="stat-value" id="honeyCells">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Hive Size</div>
                <div class="stat-value" id="hiveSize">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Active Bees</div>
                <div class="stat-value" id="activeBees">0</div>
            </div>
        </div>
        
        <div class="stats" style="margin-top: 10px;">
            <div class="stat-item">
                <div class="stat-label">ü•ö Eggs</div>
                <div class="stat-value" id="eggCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üêõ Larvae</div>
                <div class="stat-value" id="larvaCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ü¶ã Pupae</div>
                <div class="stat-value" id="pupaCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">üëë Queen Eggs</div>
                <div class="stat-value" id="queenEggs">0</div>
            </div>
        </div>
        
        <div class="tips">
            <div class="tips-title">üí° Interactive Tips</div>
            <ul class="tips-list">
                <li><span class="tip-icon">üñ±Ô∏è</span><strong>Click on a bee or cell</strong> to track it (works when paused too!)</li>
                <li><span class="tip-icon">üìä</span><strong>Tracked stats</strong> appear in the side panel for continuous monitoring</li>
                <li><span class="tip-icon">üëÜ</span><strong>Hover over bees or cells</strong> to see detailed information</li>
                <li><span class="tip-icon">‚ö°</span><strong>Adjust speed</strong> to watch in slow motion or fast forward</li>
                <li><span class="tip-icon">üìè</span><strong>Change hive size live</strong> without interrupting the simulation</li>
                <li><span class="tip-icon">üîÑ</span><strong>Track both simultaneously</strong> - bees (right panel) and cells (left panel) independently</li>
            </ul>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">üìà Growth Trends</div>
            <div class="mini-chart">
                <svg id="growthChart" width="100%" height="100%" style="display: block;"></svg>
            </div>
            <div class="chart-legend">
                <div class="chart-legend-item">
                    <div class="chart-legend-color" style="background: #667eea;"></div>
                    <span>Total Cells</span>
                </div>
                <div class="chart-legend-item">
                    <div class="chart-legend-color" style="background: #FFD700;"></div>
                    <span>Honey Cells</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('beehiveCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const config = {
            hexSize: 15,
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            colonySize: 10,
            resourceAvailability: 50,
            maxRings: 8,
            simulationSpeed: 0.5,
            isPaused: false,
            beeNaming: {
                enabled: true,
                format: 'mixed' // 'number', 'name', or 'mixed'
            }
        };
        
        // Hexagon cells
        const cells = [];
        
        // Bees
        const bees = [];
        
        // Queen bee
        let queenBee = null;
        
        // Bee types
        const BEE_TYPES = {
            QUEEN: 'queen',
            FORAGER: 'forager',
            BUILDER: 'builder',
            NURSE: 'nurse',
            SCOUT: 'scout',
            DRONE: 'drone'
        };
        
        // Shared resource information (waggle dance communication)
        const sharedResources = []; // Array of {cell, discoveredBy, danceCountdown}
        
        // Overcrowding threshold
        const OVERCROWDING_THRESHOLD = 0.8; // bees per cell ratio
        
        // Tracking
        let trackedBee = null;
        let trackedCell = null;
        
        // Tooltip
        const tooltip = document.getElementById('tooltip');
        
        // Tracked bee stats panel
        const trackedBeeStats = document.getElementById('trackedBeeStats');
        const trackedBeeContent = document.getElementById('trackedBeeContent');
        
        // Tracked cell stats panel
        const trackedCellStats = document.getElementById('trackedCellStats');
        const trackedCellContent = document.getElementById('trackedCellContent');
        
        // Stats history for graphs
        const statsHistory = {
            totalCells: [],
            honeyCells: [],
            maxHistory: 60  // Keep last 60 data points
        };
        
        // Chart update counter
        let chartUpdateCounter = 0;
        
        // Bee name generation
        const beeNameParts = [
            'buzz', 'honey', 'nectar', 'pollen', 'amber', 'gold', 'sun', 'flower',
            'bee', 'wing', 'sting', 'hive', 'comb', 'wax', 'royal', 'queen',
            'ben', 'buzz', 'buzzy', 'honey', 'amber', 'goldie', 'sunny', 'flora'
        ];
        
        let beeCounter = 0; // Counter for numbered names
        
        function generateBeeName(beeType) {
            if (!config.beeNaming.enabled) {
                return null;
            }
            
            const typePrefix = beeType === BEE_TYPES.QUEEN ? 'queen' : beeType;
            const format = config.beeNaming.format;
            
            if (format === 'number') {
                beeCounter++;
                return `${typePrefix}#${String(beeCounter).padStart(3, '0')}`;
            } else if (format === 'name') {
                const randomPart = beeNameParts[Math.floor(Math.random() * beeNameParts.length)];
                return `${typePrefix}-${randomPart}`;
            } else { // 'mixed'
                if (Math.random() < 0.5) {
                    beeCounter++;
                    return `${typePrefix}#${String(beeCounter).padStart(3, '0')}`;
                } else {
                    const randomPart = beeNameParts[Math.floor(Math.random() * beeNameParts.length)];
                    return `${typePrefix}-${randomPart}`;
                }
            }
        }
        
        // Cell types
        const CELL_TYPES = {
            EMPTY: 'empty',
            BUILDING: 'building',
            HONEY: 'honey',
            BROOD: 'brood',
            EGG: 'egg',
            LARVA: 'larva',
            PUPA: 'pupa'
        };
        
        // Lifecycle stages
        const LIFECYCLE_STAGES = {
            EGG: 'egg',
            LARVA: 'larva',
            PUPA: 'pupa',
            ADULT: 'adult'
        };
        
        // Initialize hexagonal grid
        function initializeGrid() {
            cells.length = 0;
            
            // Center cell
            cells.push({
                q: 0,
                r: 0,
                x: config.centerX,
                y: config.centerY,
                type: CELL_TYPES.EMPTY,
                honeyLevel: 0,
                buildProgress: 1,
                age: 0,
                transitionProgress: 1,
                previousType: CELL_TYPES.EMPTY,
                lifecycleStage: null,
                lifecycleProgress: 0,
                royalJelly: false
            });
            
            // Create rings of hexagons
            for (let ring = 1; ring <= config.maxRings; ring++) {
                const hexagons = getHexRing(0, 0, ring);
                hexagons.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r);
                    cells.push({
                        q: hex.q,
                        r: hex.r,
                        x: pos.x,
                        y: pos.y,
                        type: CELL_TYPES.EMPTY,
                        honeyLevel: 0,
                        buildProgress: 0,
                        age: 0,
                        transitionProgress: 1,
                        previousType: CELL_TYPES.EMPTY,
                        lifecycleStage: null,
                        lifecycleProgress: 0,
                        royalJelly: false
                    });
                });
            }
        }
        
        // Get hexagons in a ring
        function getHexRing(centerQ, centerR, radius) {
            const results = [];
            if (radius === 0) return results;
            
            let q = centerQ;
            let r = centerR - radius;
            
            const directions = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
            ];
            
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < radius; j++) {
                    results.push({ q, r });
                    q += directions[i][0];
                    r += directions[i][1];
                }
            }
            
            return results;
        }
        
        // Convert hex coordinates to pixel coordinates
        function hexToPixel(q, r) {
            const size = config.hexSize;
            const x = config.centerX + size * (3/2 * q);
            const y = config.centerY + size * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
            return { x, y };
        }
        
        function pixelToHex(x, y) {
            const size = config.hexSize;
            const q = (2/3 * (x - config.centerX)) / size;
            const r = (-1/3 * (x - config.centerX) + Math.sqrt(3)/3 * (y - config.centerY)) / size;
            return { q: Math.round(q), r: Math.round(r) };
        }
        
        // Draw hexagon
        function drawHexagon(x, y, size, fillColor, strokeColor = '#8B4513', lineWidth = 2) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const hx = x + size * Math.cos(angle);
                const hy = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }
        
        // Initialize queen bee
        function initializeQueen() {
            queenBee = {
                x: config.centerX,
                y: config.centerY,
                targetCell: null,
                speed: 0.5,
                angle: 0,
                wanderAngle: 0, // For smooth circular movement
                state: 'laying',
                eggsLaid: 0,
                lastEggTime: 0,
                royalJellyProduction: 0,
                name: generateBeeName(BEE_TYPES.QUEEN),
                type: BEE_TYPES.QUEEN
            };
        }
        
        // Initialize bees with specialization
        function initializeBees() {
            bees.length = 0;
            for (let i = 0; i < config.colonySize; i++) {
                // Assign bee type based on colony needs
                let beeType;
                const rand = Math.random();
                if (rand < 0.35) {
                    beeType = BEE_TYPES.FORAGER; // 35% foragers
                } else if (rand < 0.65) {
                    beeType = BEE_TYPES.BUILDER; // 30% builders
                } else if (rand < 0.85) {
                    beeType = BEE_TYPES.NURSE; // 20% nurses
                } else if (rand < 0.92) {
                    beeType = BEE_TYPES.SCOUT; // 7% scouts
                } else {
                    beeType = BEE_TYPES.DRONE; // 8% drones
                }
                
                bees.push({
                    x: config.centerX + (Math.random() - 0.5) * 100,
                    y: config.centerY + (Math.random() - 0.5) * 100,
                    targetCell: null,
                    speed: beeType === BEE_TYPES.FORAGER ? 3 + Math.random() * 2 : 
                           beeType === BEE_TYPES.SCOUT ? 4 + Math.random() * 2 : 
                           beeType === BEE_TYPES.DRONE ? 1.5 + Math.random() : 
                           2 + Math.random() * 2,
                    carrying: false,
                    angle: Math.random() * Math.PI * 2,
                    state: 'exploring',
                    type: beeType,
                    efficiency: beeType === BEE_TYPES.FORAGER ? 1.2 : beeType === BEE_TYPES.BUILDER ? 1.1 : 1.0,
                    name: generateBeeName(beeType),
                    // Waggle dance properties
                    isDancing: false,
                    danceCountdown: 0,
                    discoveredResource: null,
                    // Scout properties
                    scoutingTarget: null,
                    // Drone properties
                    wanderAngle: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Update queen bee
        function updateQueen() {
            if (!queenBee) return;
            
            const speedMultiplier = config.simulationSpeed;
            queenBee.lastEggTime += speedMultiplier;
            
            // Queen moves slowly around center in a smooth circle
            if (!queenBee.wanderAngle) {
                queenBee.wanderAngle = 0;
            }
            queenBee.wanderAngle += 0.01 * speedMultiplier; // Slow, smooth rotation
            
            const radius = 30;
            const targetX = config.centerX + Math.cos(queenBee.wanderAngle) * radius;
            const targetY = config.centerY + Math.sin(queenBee.wanderAngle) * radius;
            
            // Smooth movement towards target position
            const dx = targetX - queenBee.x;
            const dy = targetY - queenBee.y;
            const moveSpeed = 0.3 * speedMultiplier;
            queenBee.x += dx * moveSpeed;
            queenBee.y += dy * moveSpeed;
            
            // Set angle based on movement direction
            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                queenBee.angle = Math.atan2(dy, dx);
            }
            
            // Lay eggs in empty brood cells (more frequently)
            if (queenBee.lastEggTime > 20) { // Lay egg every ~20 frames (faster for visibility)
                const emptyBroodCells = cells.filter(c => 
                    c.buildProgress === 1 && 
                    (c.type === CELL_TYPES.BROOD || c.type === CELL_TYPES.EMPTY) && 
                    !c.lifecycleStage &&
                    c.honeyLevel === 0
                );
                
                if (emptyBroodCells.length > 0) {
                    const targetCell = emptyBroodCells[Math.floor(Math.random() * emptyBroodCells.length)];
                    // Convert to brood if it's empty
                    if (targetCell.type === CELL_TYPES.EMPTY) {
                        targetCell.previousType = CELL_TYPES.EMPTY;
                        targetCell.type = CELL_TYPES.BROOD;
                        targetCell.transitionProgress = 0;
                    }
                    // Lay egg
                    targetCell.lifecycleStage = LIFECYCLE_STAGES.EGG;
                    targetCell.lifecycleProgress = 0;
                    targetCell.type = CELL_TYPES.EGG;
                    targetCell.previousType = targetCell.previousType || CELL_TYPES.BROOD;
                    targetCell.transitionProgress = 0;
                    queenBee.eggsLaid++;
                    queenBee.lastEggTime = 0;
                }
            }
            
            // Produce royal jelly occasionally
            if (Math.random() < 0.001 * speedMultiplier) {
                const broodCells = cells.filter(c => 
                    c.lifecycleStage === LIFECYCLE_STAGES.EGG || 
                    c.lifecycleStage === LIFECYCLE_STAGES.LARVA
                );
                if (broodCells.length > 0) {
                    const cell = broodCells[Math.floor(Math.random() * broodCells.length)];
                    cell.royalJelly = true;
                    queenBee.royalJellyProduction++;
                }
            }
        }
        
        // Update bees (with speed control)
        function updateBees() {
            const speedMultiplier = config.simulationSpeed;
            
            // Update shared resources (waggle dance communication)
            sharedResources.forEach((resource, index) => {
                resource.danceCountdown -= speedMultiplier;
                if (resource.danceCountdown <= 0) {
                    sharedResources.splice(index, 1);
                }
            });
            
            // Check for overcrowding
            const builtCells = cells.filter(c => c.buildProgress === 1).length;
            const isOvercrowded = builtCells > 0 && (bees.length / builtCells) > OVERCROWDING_THRESHOLD;
            
            bees.forEach(bee => {
                // Handle waggle dance
                if (bee.isDancing) {
                    bee.danceCountdown -= speedMultiplier;
                    if (bee.danceCountdown <= 0) {
                        bee.isDancing = false;
                        bee.danceCountdown = 0;
                        // Share resource information
                        if (bee.discoveredResource) {
                            sharedResources.push({
                                cell: bee.discoveredResource,
                                discoveredBy: bee,
                                danceCountdown: 60 // Resource info lasts 60 frames
                            });
                            bee.discoveredResource = null;
                        }
                    }
                }
                
                // Drone behavior - wander around, don't work
                if (bee.type === BEE_TYPES.DRONE) {
                    if (!bee.wanderAngle) bee.wanderAngle = Math.random() * Math.PI * 2;
                    bee.wanderAngle += 0.02 * speedMultiplier;
                    const wanderRadius = 50;
                    const targetX = config.centerX + Math.cos(bee.wanderAngle) * wanderRadius;
                    const targetY = config.centerY + Math.sin(bee.wanderAngle) * wanderRadius;
                    const dx = targetX - bee.x;
                    const dy = targetY - bee.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 2) {
                        bee.x += (dx / distance) * bee.speed * speedMultiplier;
                        bee.y += (dy / distance) * bee.speed * speedMultiplier;
                        bee.angle = Math.atan2(dy, dx);
                    }
                    // Drones occasionally approach queen
                    if (queenBee && Math.random() < 0.005) {
                        const qdx = queenBee.x - bee.x;
                        const qdy = queenBee.y - bee.y;
                        const qdist = Math.sqrt(qdx * qdx + qdy * qdy);
                        if (qdist > 30) {
                            bee.x += (qdx / qdist) * bee.speed * speedMultiplier * 0.5;
                            bee.y += (qdy / qdist) * bee.speed * speedMultiplier * 0.5;
                        }
                    }
                    return; // Skip normal bee logic for drones
                }
                
                // Scout behavior - explore edges when overcrowded
                if (bee.type === BEE_TYPES.SCOUT) {
                    if (isOvercrowded) {
                        // Scout explores edges of hive
                        if (!bee.scoutingTarget || Math.random() < 0.05) {
                            // Find edge cells or empty space beyond hive
                            const edgeCells = cells.filter(c => {
                                const neighbors = getNeighbors(c.q, c.r);
                                const builtNeighbors = neighbors.filter(n => n && n.buildProgress === 1).length;
                                return c.buildProgress === 1 && builtNeighbors < 6;
                            });
                            if (edgeCells.length > 0) {
                                bee.scoutingTarget = edgeCells[Math.floor(Math.random() * edgeCells.length)];
                                bee.targetCell = bee.scoutingTarget;
                                bee.state = 'scouting';
                            } else {
                                // Explore beyond hive
                                const maxDist = Math.max(...cells.map(c => Math.sqrt(c.q * c.q + c.r * c.r + c.q * c.r)));
                                const angle = Math.random() * Math.PI * 2;
                                const dist = maxDist + 2;
                                const hex = pixelToHex(
                                    config.centerX + Math.cos(angle) * dist * config.hexSize * 1.5,
                                    config.centerY + Math.sin(angle) * dist * config.hexSize * 1.5
                                );
                                const pos = hexToPixel(hex.q, hex.r);
                                bee.scoutingTarget = { x: pos.x, y: pos.y, q: hex.q, r: hex.r };
                                bee.targetCell = bee.scoutingTarget;
                                bee.state = 'scouting';
                            }
                        }
                    } else {
                        // When not overcrowded, scouts act like foragers but keep scout type
                        // They'll use the forager logic below
                    }
                }
                
                // Check for shared resources (waggle dance communication)
                if (bee.type === BEE_TYPES.FORAGER && !bee.carrying && !bee.targetCell && sharedResources.length > 0) {
                    const nearbyResource = sharedResources.find(r => {
                        const dx = r.cell.x - bee.x;
                        const dy = r.cell.y - bee.y;
                        return Math.sqrt(dx * dx + dy * dy) < 100; // Within 100 pixels
                    });
                    if (nearbyResource && Math.random() < 0.3) {
                        // Learn about resource from waggle dance
                        bee.targetCell = nearbyResource.cell;
                        bee.state = 'foraging';
                    }
                }
                
                if (!bee.targetCell || Math.random() < 0.01) {
                    // Select new target
                    const builtCells = cells.filter(c => c.buildProgress > 0);
                    if (builtCells.length > 0) {
                        // Prioritize cells based on bee type and state
                        if (bee.type === BEE_TYPES.FORAGER || (bee.type === BEE_TYPES.SCOUT && !isOvercrowded)) {
                            // Foragers focus on collecting resources
                            if (bee.carrying) {
                                // Store honey
                                const emptyCells = builtCells.filter(c => 
                                    c.buildProgress === 1 && 
                                    c.honeyLevel < 1 && 
                                    c.type !== CELL_TYPES.BROOD
                                );
                                bee.targetCell = emptyCells[Math.floor(Math.random() * emptyCells.length)] || 
                                               builtCells[Math.floor(Math.random() * builtCells.length)];
                                bee.state = 'storing';
                            } else {
                                // Go out to collect (simulated by finding empty cells)
                                const emptyCells = builtCells.filter(c => 
                                    c.buildProgress === 1 && 
                                    c.honeyLevel < 0.5
                                );
                                bee.targetCell = emptyCells[Math.floor(Math.random() * emptyCells.length)] || 
                                               builtCells[Math.floor(Math.random() * builtCells.length)];
                                bee.state = 'foraging';
                            }
                        } else if (bee.type === BEE_TYPES.BUILDER) {
                            // Builders focus on construction
                            const unbuildCells = cells.filter(c => 
                                c.buildProgress > 0 && 
                                c.buildProgress < 1
                            );
                            if (unbuildCells.length > 0) {
                                bee.targetCell = unbuildCells[Math.floor(Math.random() * unbuildCells.length)];
                                bee.state = 'building';
                            } else {
                                // Help with storage if no building needed
                                const emptyCells = builtCells.filter(c => 
                                    c.buildProgress === 1 && 
                                    c.honeyLevel < 1 && 
                                    c.type !== CELL_TYPES.BROOD
                                );
                                bee.targetCell = emptyCells[Math.floor(Math.random() * emptyCells.length)] || 
                                               builtCells[Math.floor(Math.random() * builtCells.length)];
                                bee.state = 'storing';
                            }
                        } else if (bee.type === BEE_TYPES.NURSE) {
                            // Nurses focus on brood cells
                            const broodCells = builtCells.filter(c => c.type === CELL_TYPES.BROOD);
                            if (broodCells.length > 0) {
                                bee.targetCell = broodCells[Math.floor(Math.random() * broodCells.length)];
                                bee.state = 'nursing';
                            } else {
                                // Help with storage if no brood
                                const emptyCells = builtCells.filter(c => 
                                    c.buildProgress === 1 && 
                                    c.honeyLevel < 1
                                );
                                bee.targetCell = emptyCells[Math.floor(Math.random() * emptyCells.length)] || 
                                               builtCells[Math.floor(Math.random() * builtCells.length)];
                                bee.state = 'storing';
                            }
                        }
                    }
                }
                
                // Move towards target
                if (bee.targetCell) {
                    const dx = bee.targetCell.x - bee.x;
                    const dy = bee.targetCell.y - bee.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        bee.x += (dx / distance) * bee.speed * speedMultiplier;
                        bee.y += (dy / distance) * bee.speed * speedMultiplier;
                        bee.angle = Math.atan2(dy, dx);
                    } else {
                        // Reached target - behavior based on bee type
                        if (bee.state === 'storing' && bee.carrying) {
                            const amount = 0.02 * bee.efficiency;
                            bee.targetCell.honeyLevel = Math.min(1, bee.targetCell.honeyLevel + amount);
                            if (bee.targetCell.honeyLevel > 0.3 && bee.targetCell.type !== CELL_TYPES.HONEY) {
                                bee.targetCell.previousType = bee.targetCell.type;
                                bee.targetCell.type = CELL_TYPES.HONEY;
                                bee.targetCell.transitionProgress = 0;
                            }
                            bee.carrying = false;
                            bee.targetCell = null;
                        } else if (bee.state === 'building') {
                            // Builders contribute to construction
                            const buildAmount = 0.005 * bee.efficiency * speedMultiplier;
                            bee.targetCell.buildProgress = Math.min(1, bee.targetCell.buildProgress + buildAmount);
                            if (bee.targetCell.buildProgress >= 1) {
                                bee.targetCell = null;
                            }
                        } else if (bee.state === 'foraging') {
                            // Foragers collect resources
                            bee.carrying = Math.random() < (config.resourceAvailability / 100) * bee.efficiency;
                            if (bee.carrying && bee.type === BEE_TYPES.FORAGER) {
                                // Perform waggle dance to share resource location
                                bee.isDancing = true;
                                bee.danceCountdown = 30; // Dance for 30 frames
                                bee.discoveredResource = bee.targetCell;
                            }
                            bee.targetCell = null;
                        } else if (bee.state === 'nursing') {
                            // Nurses tend to brood cells
                            bee.targetCell = null;
                        }
                    }
                }
                
                // Add some wandering
                bee.angle += (Math.random() - 0.5) * 0.3;
            });
        }
        
        // Update cells (with speed control)
        function updateCells() {
            const speedMultiplier = config.simulationSpeed;
            
            cells.forEach(cell => {
                cell.age += speedMultiplier;
                
                // Update lifecycle progression
                if (cell.lifecycleStage) {
                    cell.lifecycleProgress += 0.01 * speedMultiplier; // Faster progression for visibility
                    
                    if (cell.lifecycleStage === LIFECYCLE_STAGES.EGG && cell.lifecycleProgress >= 0.33) {
                        // Egg -> Larva
                        cell.previousType = cell.type;
                        cell.lifecycleStage = LIFECYCLE_STAGES.LARVA;
                        cell.type = CELL_TYPES.LARVA;
                        cell.lifecycleProgress = 0;
                        cell.transitionProgress = 0;
                    } else if (cell.lifecycleStage === LIFECYCLE_STAGES.LARVA && cell.lifecycleProgress >= 0.33) {
                        // Larva -> Pupa
                        cell.previousType = cell.type;
                        cell.lifecycleStage = LIFECYCLE_STAGES.PUPA;
                        cell.type = CELL_TYPES.PUPA;
                        cell.lifecycleProgress = 0;
                        cell.transitionProgress = 0;
                    } else if (cell.lifecycleStage === LIFECYCLE_STAGES.PUPA && cell.lifecycleProgress >= 0.33) {
                        // Pupa -> Adult (new bee is born)
                        cell.previousType = cell.type;
                        cell.lifecycleStage = null;
                        cell.type = CELL_TYPES.BROOD;
                        cell.lifecycleProgress = 0;
                        cell.transitionProgress = 0;
                        cell.royalJelly = false;
                        
                        // Add new bee to colony
                        if (bees.length < config.colonySize * 2) { // Max 2x colony size
                            const rand = Math.random();
                            let beeType;
                            if (rand < 0.35) {
                                beeType = BEE_TYPES.FORAGER;
                            } else if (rand < 0.65) {
                                beeType = BEE_TYPES.BUILDER;
                            } else if (rand < 0.85) {
                                beeType = BEE_TYPES.NURSE;
                            } else if (rand < 0.92) {
                                beeType = BEE_TYPES.SCOUT;
                            } else {
                                beeType = BEE_TYPES.DRONE;
                            }
                            
                            bees.push({
                                x: cell.x + (Math.random() - 0.5) * 20,
                                y: cell.y + (Math.random() - 0.5) * 20,
                                targetCell: null,
                                speed: beeType === BEE_TYPES.FORAGER ? 3 + Math.random() * 2 : 
                                       beeType === BEE_TYPES.SCOUT ? 4 + Math.random() * 2 : 
                                       beeType === BEE_TYPES.DRONE ? 1.5 + Math.random() : 
                                       2 + Math.random() * 2,
                                carrying: false,
                                angle: Math.random() * Math.PI * 2,
                                state: 'exploring',
                                type: beeType,
                                efficiency: beeType === BEE_TYPES.FORAGER ? 1.2 : beeType === BEE_TYPES.BUILDER ? 1.1 : 1.0,
                                name: generateBeeName(beeType),
                                // Waggle dance properties
                                isDancing: false,
                                danceCountdown: 0,
                                discoveredResource: null,
                                // Scout properties
                                scoutingTarget: null,
                                // Drone properties
                                wanderAngle: Math.random() * Math.PI * 2
                            });
                        }
                    }
                }
                
                // Gradually build cells from center outward
                if (cell.buildProgress < 1) {
                    const distanceFromCenter = Math.sqrt(cell.q * cell.q + cell.r * cell.r);
                    const buildRate = (config.resourceAvailability / 100) * 0.003;
                    
                    // Cells closer to center build faster
                    if (distanceFromCenter < 2) {
                        cell.buildProgress = Math.min(1, cell.buildProgress + buildRate * 2);
                    } else {
                        // Check if neighboring cells are built
                        const neighbors = getNeighbors(cell.q, cell.r);
                        const builtNeighbors = neighbors.filter(n => n && n.buildProgress === 1).length;
                        
                        if (builtNeighbors > 0) {
                            cell.buildProgress = Math.min(1, cell.buildProgress + buildRate * (builtNeighbors / 3));
                        }
                    }
                }
                
                // Randomly convert some cells to brood (if not already a lifecycle cell) - more frequently
                if (cell.buildProgress === 1 && cell.type === CELL_TYPES.EMPTY && !cell.lifecycleStage && Math.random() < 0.001) {
                    cell.previousType = cell.type;
                    cell.type = CELL_TYPES.BROOD;
                    cell.transitionProgress = 0;
                }
                
                // Brood cells mature and become empty again after some time
                if (cell.type === CELL_TYPES.BROOD && cell.age > 2000 && Math.random() < 0.001) {
                    cell.previousType = cell.type;
                    cell.type = CELL_TYPES.EMPTY;
                    cell.transitionProgress = 0;
                    cell.age = 0;
                }
                
                // Update transition progress
                if (cell.transitionProgress < 1) {
                    cell.transitionProgress = Math.min(1, cell.transitionProgress + 0.01 * speedMultiplier);
                }
            });
        }
        
        // Get neighboring cells
        function getNeighbors(q, r) {
            const directions = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
            ];
            return directions.map(([dq, dr]) => {
                return cells.find(c => c.q === q + dq && c.r === r + dr);
            });
        }
        
        // Draw queen bee
        function drawQueen() {
            if (!queenBee) return;
            
            ctx.save();
            ctx.translate(queenBee.x, queenBee.y);
            ctx.rotate(queenBee.angle);
            
            // Larger size for queen
            const queenSize = 10;
            
            // Crown/royal indicator (always points up relative to bee)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, -queenSize - 3);
            ctx.lineTo(-3, -queenSize);
            ctx.lineTo(0, -queenSize + 2);
            ctx.lineTo(3, -queenSize);
            ctx.closePath();
            ctx.fill();
            
            // Body - larger and more regal
            ctx.fillStyle = '#FF69B4'; // Pink/magenta for queen
            ctx.beginPath();
            ctx.ellipse(0, 0, queenSize, queenSize * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Stripes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-3, -queenSize * 0.7);
            ctx.lineTo(-3, queenSize * 0.7);
            ctx.moveTo(3, -queenSize * 0.7);
            ctx.lineTo(3, queenSize * 0.7);
            ctx.stroke();
            
            // Wings (smaller than worker bees, more elegant)
            const wingFlap = Math.sin(Date.now() / 100) * 0.2;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.ellipse(-2, -2, 3, 1.5, -0.3 + wingFlap, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-2, 2, 3, 1.5, 0.3 - wingFlap, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw bee
        function drawBee(bee) {
            ctx.save();
            ctx.translate(bee.x, bee.y);
            
            // Highlight tracked bee (works even when paused)
            if (bee === trackedBee) {
                // Outer glow ring
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Inner tracking ring
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw tracking line from bee to target (even when paused)
                if (bee.targetCell) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(bee.targetCell.x - bee.x, bee.targetCell.y - bee.y);
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw target indicator
                    ctx.save();
                    ctx.translate(bee.targetCell.x - bee.x, bee.targetCell.y - bee.y);
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            ctx.rotate(bee.angle);
            
            // Waggle dance animation
            if (bee.isDancing) {
                const danceTime = 30 - bee.danceCountdown;
                const danceOffset = Math.sin(danceTime * 0.3) * 3; // Figure-8 pattern
                ctx.translate(danceOffset, Math.cos(danceTime * 0.3) * 2);
                
                // Draw dance indicator
                ctx.beginPath();
                ctx.arc(0, -8, 8, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Body - color based on bee type
            let bodyColor;
            let bodySize = 4; // Default size
            if (bee.type === BEE_TYPES.FORAGER) {
                bodyColor = bee.carrying ? '#FFD700' : '#FFA500'; // Golden when carrying, orange when empty
            } else if (bee.type === BEE_TYPES.BUILDER) {
                bodyColor = '#FF8C00'; // Dark orange
            } else if (bee.type === BEE_TYPES.NURSE) {
                bodyColor = '#90EE90'; // Light green
            } else if (bee.type === BEE_TYPES.SCOUT) {
                bodyColor = '#87CEEB'; // Sky blue for scouts
            } else if (bee.type === BEE_TYPES.DRONE) {
                bodyColor = '#8B4513'; // Brown for drones
                bodySize = 6; // Drones are larger
            } else {
                bodyColor = bee.carrying ? '#FFD700' : '#FFA500';
            }
            
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(0, 0, bodySize, bodySize * 0.75, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Scout marker - small triangle on top
            if (bee.type === BEE_TYPES.SCOUT) {
                ctx.fillStyle = '#4169E1';
                ctx.beginPath();
                ctx.moveTo(0, -bodySize - 2);
                ctx.lineTo(-3, -bodySize + 2);
                ctx.lineTo(3, -bodySize + 2);
                ctx.closePath();
                ctx.fill();
            }
            
            // Drone - larger eyes
            if (bee.type === BEE_TYPES.DRONE) {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-2, -1, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(2, -1, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Stripes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-2, -bodySize * 0.75);
            ctx.lineTo(-2, bodySize * 0.75);
            ctx.moveTo(2, -bodySize * 0.75);
            ctx.lineTo(2, bodySize * 0.75);
            ctx.stroke();
            
            // Wings
            const wingFlap = Math.sin(Date.now() / 50) * 0.3;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-2, -2, 4, 2, -0.5 + wingFlap, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-2, 2, 4, 2, 0.5 - wingFlap, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Get color for cell type
        function getCellColor(type, honeyLevel, lifecycleStage, royalJelly) {
            if (type === CELL_TYPES.EGG) {
                return { r: 255, g: 255, b: 200 }; // Light yellow for eggs
            } else if (type === CELL_TYPES.LARVA) {
                return { r: 255, g: 200, b: 150 }; // Light orange for larvae
            } else if (type === CELL_TYPES.PUPA) {
                return { r: 200, g: 200, b: 255 }; // Light purple for pupae
            } else if (type === CELL_TYPES.BROOD) {
                return { r: 232, g: 232, b: 232 };
            } else if (type === CELL_TYPES.HONEY) {
                const intensity = Math.floor(255 - honeyLevel * 100);
                return { r: 255, g: intensity, b: 0 };
            } else {
                return { r: 255, g: 244, b: 230 };
            }
        }
        
        // Interpolate between two colors
        function interpolateColor(color1, color2, progress) {
            const r = Math.floor(color1.r + (color2.r - color1.r) * progress);
            const g = Math.floor(color1.g + (color2.g - color1.g) * progress);
            const b = Math.floor(color1.b + (color2.b - color1.b) * progress);
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Draw cell
        function drawCell(cell) {
            let fillColor;
            
            if (cell.buildProgress === 0) {
                return; // Don't draw unbuilt cells
            } else if (cell.buildProgress < 1) {
                // Building
                fillColor = `rgba(255, 244, 230, ${cell.buildProgress})`;
            } else if (cell.transitionProgress < 1) {
                // Transitioning between cell types
                const previousColor = getCellColor(cell.previousType, cell.honeyLevel, cell.lifecycleStage, cell.royalJelly);
                const currentColor = getCellColor(cell.type, cell.honeyLevel, cell.lifecycleStage, cell.royalJelly);
                fillColor = interpolateColor(previousColor, currentColor, cell.transitionProgress);
            } else if (cell.type === CELL_TYPES.EGG || cell.lifecycleStage === LIFECYCLE_STAGES.EGG) {
                fillColor = '#FFF9C4'; // Bright yellow for eggs (more visible)
            } else if (cell.type === CELL_TYPES.LARVA || cell.lifecycleStage === LIFECYCLE_STAGES.LARVA) {
                fillColor = '#FFCC80'; // Bright orange for larvae (more visible)
            } else if (cell.type === CELL_TYPES.PUPA || cell.lifecycleStage === LIFECYCLE_STAGES.PUPA) {
                fillColor = '#CE93D8'; // Bright purple for pupae (more visible)
            } else if (cell.type === CELL_TYPES.BROOD) {
                fillColor = '#E8E8E8';
            } else if (cell.type === CELL_TYPES.HONEY) {
                const intensity = Math.floor(255 - cell.honeyLevel * 100);
                fillColor = `rgb(255, ${intensity}, 0)`;
            } else {
                fillColor = '#fff4e6';
            }
            
            const size = config.hexSize * cell.buildProgress;
            
            // Highlight tracked cell
            if (cell === trackedCell) {
                // Draw outer glow
                ctx.shadowColor = 'rgba(100, 150, 255, 0.8)';
                ctx.shadowBlur = 15;
                drawHexagon(cell.x, cell.y, size + 2, fillColor);
                ctx.shadowBlur = 0;
                
                // Draw lines to incoming bees
                bees.forEach(bee => {
                    if (bee.targetCell === cell) {
                        ctx.beginPath();
                        ctx.moveTo(cell.x, cell.y);
                        ctx.lineTo(bee.x, bee.y);
                        ctx.strokeStyle = 'rgba(100, 150, 255, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Draw arrow at bee end
                        const angle = Math.atan2(bee.y - cell.y, bee.x - cell.x);
                        ctx.save();
                        ctx.translate(bee.x, bee.y);
                        ctx.rotate(angle);
                        ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-8, -4);
                        ctx.lineTo(-8, 4);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                });
            }
            
            drawHexagon(cell.x, cell.y, size, fillColor);
            
            // Draw lifecycle indicators (check both lifecycleStage and type for reliability)
            // Make them more prominent and visible
            if (cell.lifecycleStage === LIFECYCLE_STAGES.EGG || cell.type === CELL_TYPES.EGG) {
                // Draw egg - white circle with bright yellow background (more prominent)
                ctx.fillStyle = '#FFEB3B'; // Bright yellow background
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFFFF'; // White egg
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Small highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(cell.x - size * 0.12, cell.y - size * 0.12, size * 0.1, 0, Math.PI * 2);
                ctx.fill();
                // Add border for visibility
                ctx.strokeStyle = '#FFC107';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, size * 0.3, 0, Math.PI * 2);
                ctx.stroke();
            } else if (cell.lifecycleStage === LIFECYCLE_STAGES.LARVA || cell.type === CELL_TYPES.LARVA) {
                // Draw larva - orange wiggly shape (more prominent)
                ctx.fillStyle = '#FF6B00'; // Bright orange
                ctx.beginPath();
                ctx.ellipse(cell.x, cell.y, size * 0.35, size * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                // Add segments for more realistic look
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.ellipse(cell.x - size * 0.18, cell.y, size * 0.12, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cell.x + size * 0.18, cell.y, size * 0.12, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();
                // Add border
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.ellipse(cell.x, cell.y, size * 0.35, size * 0.25, 0, 0, Math.PI * 2);
                ctx.stroke();
            } else if (cell.lifecycleStage === LIFECYCLE_STAGES.PUPA || cell.type === CELL_TYPES.PUPA) {
                // Draw pupa - purple cocoon shape (more prominent)
                ctx.fillStyle = '#9C27B0'; // Bright purple
                ctx.beginPath();
                ctx.ellipse(cell.x, cell.y, size * 0.3, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                // Add darker outline
                ctx.strokeStyle = '#7B1FA2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(cell.x, cell.y, size * 0.3, size * 0.4, 0, 0, Math.PI * 2);
                ctx.stroke();
                // Add segments/lines
                ctx.strokeStyle = '#6A1B9A';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(cell.x - size * 0.25, cell.y - size * 0.25);
                ctx.lineTo(cell.x + size * 0.25, cell.y - size * 0.25);
                ctx.moveTo(cell.x - size * 0.25, cell.y);
                ctx.lineTo(cell.x + size * 0.25, cell.y);
                ctx.moveTo(cell.x - size * 0.25, cell.y + size * 0.25);
                ctx.lineTo(cell.x + size * 0.25, cell.y + size * 0.25);
                ctx.stroke();
            }
            
            // Draw royal jelly indicator (sparkle effect)
            if (cell.royalJelly) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(cell.x - size * 0.3, cell.y - size * 0.3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cell.x + size * 0.3, cell.y + size * 0.3, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw honey level indicator
            if (cell.honeyLevel > 0 && cell.type !== CELL_TYPES.BROOD && !cell.lifecycleStage) {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, size * 0.3 * cell.honeyLevel, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Update statistics
        function updateStats() {
            const totalBuilt = cells.filter(c => c.buildProgress === 1).length;
            const honeyFilled = cells.filter(c => c.honeyLevel > 0.5).length;
            
            // Calculate current hive size (furthest ring that has any built cells)
            let maxRing = 0;
            cells.forEach(cell => {
                if (cell.buildProgress > 0) {
                    const ring = Math.sqrt(cell.q * cell.q + cell.r * cell.r + cell.q * cell.r);
                    maxRing = Math.max(maxRing, Math.round(ring));
                }
            });
            
            const eggs = cells.filter(c => c.lifecycleStage === LIFECYCLE_STAGES.EGG || c.type === CELL_TYPES.EGG).length;
            const larvae = cells.filter(c => c.lifecycleStage === LIFECYCLE_STAGES.LARVA || c.type === CELL_TYPES.LARVA).length;
            const pupae = cells.filter(c => c.lifecycleStage === LIFECYCLE_STAGES.PUPA || c.type === CELL_TYPES.PUPA).length;
            
            document.getElementById('totalCells').textContent = totalBuilt;
            document.getElementById('honeyCells').textContent = honeyFilled;
            document.getElementById('hiveSize').textContent = `${maxRing} rings`;
            document.getElementById('activeBees').textContent = bees.length;
            document.getElementById('eggCount').textContent = eggs;
            document.getElementById('larvaCount').textContent = larvae;
            document.getElementById('pupaCount').textContent = pupae;
            document.getElementById('queenEggs').textContent = queenBee ? queenBee.eggsLaid : 0;
            
            // Update stats history for graphing
            statsHistory.totalCells.push(totalBuilt);
            statsHistory.honeyCells.push(honeyFilled);
            
            // Keep only recent history
            if (statsHistory.totalCells.length > statsHistory.maxHistory) {
                statsHistory.totalCells.shift();
                statsHistory.honeyCells.shift();
            }
            
            // Update chart periodically
            chartUpdateCounter++;
            if (chartUpdateCounter >= 5) { // Update chart every 5 frames
                updateChart();
                chartUpdateCounter = 0;
            }
        }
        
        // Update growth chart
        function updateChart() {
            const chart = document.getElementById('growthChart');
            const container = chart.parentElement;
            const width = container.clientWidth - 20;
            const height = container.clientHeight - 20;
            
            chart.setAttribute('width', width);
            chart.setAttribute('height', height);
            chart.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            // Clear previous content
            chart.innerHTML = '';
            
            if (statsHistory.totalCells.length < 2) return;
            
            const dataLength = statsHistory.totalCells.length;
            const maxValue = Math.max(
                Math.max(...statsHistory.totalCells),
                Math.max(...statsHistory.honeyCells)
            ) || 1;
            
            // Draw grid lines
            for (let i = 0; i <= 4; i++) {
                const y = (height / 4) * i;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', y);
                line.setAttribute('x2', width);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '1');
                chart.appendChild(line);
            }
            
            // Draw total cells line
            const totalPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            statsHistory.totalCells.forEach((value, index) => {
                const x = (width / (dataLength - 1)) * index;
                const y = height - (value / maxValue) * height;
                pathData += (index === 0 ? 'M' : 'L') + ` ${x} ${y}`;
            });
            totalPath.setAttribute('d', pathData);
            totalPath.setAttribute('class', 'chart-line chart-line-total');
            chart.appendChild(totalPath);
            
            // Draw honey cells line
            const honeyPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathData = '';
            statsHistory.honeyCells.forEach((value, index) => {
                const x = (width / (dataLength - 1)) * index;
                const y = height - (value / maxValue) * height;
                pathData += (index === 0 ? 'M' : 'L') + ` ${x} ${y}`;
            });
            honeyPath.setAttribute('d', pathData);
            honeyPath.setAttribute('class', 'chart-line chart-line-honey');
            chart.appendChild(honeyPath);
        }
        
        // Show tooltip
        function showTooltip(x, y, content) {
            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
        }
        
        // Hide tooltip
        function hideTooltip() {
            tooltip.style.display = 'none';
        }
        
        // Get cell at position
        function getCellAtPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            for (let cell of cells) {
                const dx = canvasX - cell.x;
                const dy = canvasY - cell.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < config.hexSize) {
                    return cell;
                }
            }
            return null;
        }
        
        // Get bee at position
        function getBeeAtPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            for (let bee of bees) {
                const dx = canvasX - bee.x;
                const dy = canvasY - bee.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 10) {
                    return bee;
                }
            }
            return null;
        }
        
        // Animation loop
        function animate() {
            if (!config.isPaused) {
                // Clear canvas
                ctx.fillStyle = '#FFF9E6';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update
                updateCells();
                updateBees();
                
                // Draw cells
                cells.forEach(drawCell);
                
                // Draw queen
                drawQueen();
                
                // Draw bees
                bees.forEach(drawBee);
                
                // Update queen
                updateQueen();
                
                // Update stats
                updateStats();
                
                // Update tracked stats panels
                updateAllTrackedStats();
            } else {
                // Still update stats panels when paused
                updateAllTrackedStats();
            }
            
            requestAnimationFrame(animate);
        }
        
        // Update tracked bee stats panel
        function updateTrackedBeeStats() {
            if (!trackedBee) {
                trackedBeeStats.classList.remove('visible');
                trackedBeeContent.innerHTML = '<div class="no-bee-tracked">No bee tracked<br>Click a bee to track it</div>';
            } else {
                trackedBeeStats.classList.add('visible');
                updateTrackedBeeStatsContent();
            }
        }
        
        // Update tracked cell stats panel
        function updateTrackedCellStats() {
            if (!trackedCell) {
                trackedCellStats.classList.remove('visible');
                trackedCellContent.innerHTML = '<div class="no-bee-tracked">No cell tracked<br>Click a cell to track it</div>';
            } else {
                trackedCellStats.classList.add('visible');
                updateTrackedCellStatsContent();
            }
        }
        
        // Update both panels
        function updateAllTrackedStats() {
            updateTrackedBeeStats();
            updateTrackedCellStats();
        }
        
        // Update tracked cell stats content
        function updateTrackedCellStatsContent() {
            const cell = trackedCell;
            
            const lifecycleNames = {
                [LIFECYCLE_STAGES.EGG]: 'Egg',
                [LIFECYCLE_STAGES.LARVA]: 'Larva',
                [LIFECYCLE_STAGES.PUPA]: 'Pupa'
            };
            
            const typeNames = {
                [CELL_TYPES.EMPTY]: 'Empty',
                [CELL_TYPES.BROOD]: 'Brood',
                [CELL_TYPES.HONEY]: 'Honey',
                [CELL_TYPES.EGG]: 'Egg',
                [CELL_TYPES.LARVA]: 'Larva',
                [CELL_TYPES.PUPA]: 'Pupa',
                [CELL_TYPES.BUILDING]: 'Building'
            };
            
            // Find bees targeting this cell (incoming)
            const incomingBees = bees.filter(bee => bee.targetCell === cell);
            const incomingBeeTypes = incomingBees.map(bee => {
                const typeNames = {
                    [BEE_TYPES.FORAGER]: 'Forager',
                    [BEE_TYPES.BUILDER]: 'Builder',
                    [BEE_TYPES.NURSE]: 'Nurse',
                    [BEE_TYPES.SCOUT]: 'Scout',
                    [BEE_TYPES.DRONE]: 'Drone'
                };
                return typeNames[bee.type] || bee.type;
            });
            
            // Find bees that recently visited this cell (within last 50 frames)
            // We'll track bees that are near this cell
            const nearbyBees = bees.filter(bee => {
                const dx = bee.x - cell.x;
                const dy = bee.y - cell.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < 30; // Within 30 pixels
            });
            
            // Count bees by type
            const beeTypeCounts = {
                forager: incomingBees.filter(b => b.type === BEE_TYPES.FORAGER).length,
                builder: incomingBees.filter(b => b.type === BEE_TYPES.BUILDER).length,
                nurse: incomingBees.filter(b => b.type === BEE_TYPES.NURSE).length,
                scout: incomingBees.filter(b => b.type === BEE_TYPES.SCOUT).length,
                drone: incomingBees.filter(b => b.type === BEE_TYPES.DRONE).length
            };
            
            trackedCellContent.innerHTML = `
                <div class="tracked-bee-stats-grid">
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Type</span>
                            <span class="tracked-stat-value">${typeNames[cell.type] || cell.type}</span>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">ü•ö Lifecycle Stage</span>
                            <span class="tracked-stat-value" style="${cell.lifecycleStage ? 'font-weight: bold; color: #667eea;' : 'color: #999;'}">
                                ${cell.lifecycleStage ? 
                                    (cell.lifecycleStage === LIFECYCLE_STAGES.EGG ? 'ü•ö ' : 
                                     cell.lifecycleStage === LIFECYCLE_STAGES.LARVA ? 'üêõ ' : 
                                     cell.lifecycleStage === LIFECYCLE_STAGES.PUPA ? 'ü¶ã ' : '') + 
                                    lifecycleNames[cell.lifecycleStage] : 
                                    'None'}
                            </span>
                        </div>
                        ${cell.lifecycleStage ? `
                        <div class="tracked-stat-item" style="margin-top: 5px;">
                            <span class="tracked-stat-label">üìà Growth Progress</span>
                            <span class="tracked-stat-value" style="font-weight: bold; color: #667eea;">${((cell.lifecycleProgress || 0) * 100).toFixed(1)}%</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill" style="width: ${Math.min(100, (cell.lifecycleProgress || 0) * 100)}%"></div>
                        </div>
                        ${cell.lifecycleStage === LIFECYCLE_STAGES.EGG ? `
                        <div style="margin-top: 5px; font-size: 11px; color: #666;">
                            Next: üêõ Larva at 33%
                        </div>
                        ` : cell.lifecycleStage === LIFECYCLE_STAGES.LARVA ? `
                        <div style="margin-top: 5px; font-size: 11px; color: #666;">
                            Next: ü¶ã Pupa at 33%
                        </div>
                        ` : cell.lifecycleStage === LIFECYCLE_STAGES.PUPA ? `
                        <div style="margin-top: 5px; font-size: 11px; color: #666;">
                            Next: üêù Adult Bee at 33%
                        </div>
                        ` : ''}
                        ` : `
                        <div class="tracked-stat-item" style="margin-top: 5px;">
                            <span class="tracked-stat-label">üìà Growth Progress</span>
                            <span class="tracked-stat-value" style="color: #999;">0%</span>
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #999; font-style: italic;">
                            No lifecycle stage active
                        </div>
                        `}
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Build Progress</span>
                            <span class="tracked-stat-value">${(cell.buildProgress * 100).toFixed(0)}%</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill" style="width: ${cell.buildProgress * 100}%"></div>
                        </div>
                    </div>
                    
                    ${cell.honeyLevel > 0 ? `
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Honey Level</span>
                            <span class="tracked-stat-value">${(cell.honeyLevel * 100).toFixed(0)}%</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill honey" style="width: ${cell.honeyLevel * 100}%"></div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Age</span>
                            <span class="tracked-stat-value">${Math.round(cell.age)} frames</span>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Coordinates</span>
                            <span class="tracked-stat-value">(${cell.q}, ${cell.r})</span>
                        </div>
                    </div>
                    
                    ${cell.royalJelly ? `
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Royal Jelly</span>
                            <span class="tracked-stat-value" style="color: #FFD700;">‚ú® Present</span>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #eee;">
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label" style="font-weight: bold; color: #667eea;">üêù Incoming Bees</span>
                            <span class="tracked-stat-value">${incomingBees.length}</span>
                        </div>
                        ${incomingBees.length > 0 ? `
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">
                            ${beeTypeCounts.forager > 0 ? `<div>‚Ä¢ ${beeTypeCounts.forager} Forager${beeTypeCounts.forager > 1 ? 's' : ''}</div>` : ''}
                            ${beeTypeCounts.builder > 0 ? `<div>‚Ä¢ ${beeTypeCounts.builder} Builder${beeTypeCounts.builder > 1 ? 's' : ''}</div>` : ''}
                            ${beeTypeCounts.nurse > 0 ? `<div>‚Ä¢ ${beeTypeCounts.nurse} Nurse${beeTypeCounts.nurse > 1 ? 's' : ''}</div>` : ''}
                            ${beeTypeCounts.scout > 0 ? `<div>‚Ä¢ ${beeTypeCounts.scout} Scout${beeTypeCounts.scout > 1 ? 's' : ''}</div>` : ''}
                            ${beeTypeCounts.drone > 0 ? `<div>‚Ä¢ ${beeTypeCounts.drone} Drone${beeTypeCounts.drone > 1 ? 's' : ''}</div>` : ''}
                        </div>
                        ${config.beeNaming.enabled ? `
                        <div style="margin-top: 8px; font-size: 11px; color: #888; max-height: 100px; overflow-y: auto;">
                            ${incomingBees.slice(0, 5).map(bee => `<div>‚Ä¢ ${bee.name || 'Unnamed'}</div>`).join('')}
                            ${incomingBees.length > 5 ? `<div style="color: #999;">... and ${incomingBees.length - 5} more</div>` : ''}
                        </div>
                        ` : ''}
                        ` : '<div style="font-size: 12px; color: #999; margin-top: 5px;">No bees targeting this cell</div>'}
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label" style="font-weight: bold; color: #667eea;">üìç Nearby Bees</span>
                            <span class="tracked-stat-value">${nearbyBees.length}</span>
                        </div>
                        ${nearbyBees.length > 0 ? `
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">
                            <div>Within 30px radius</div>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        // Update tracked bee stats content
        function updateTrackedBeeStatsContent() {
            
            const typeNames = {
                [BEE_TYPES.FORAGER]: 'Forager',
                [BEE_TYPES.BUILDER]: 'Builder',
                [BEE_TYPES.NURSE]: 'Nurse',
                [BEE_TYPES.SCOUT]: 'Scout',
                [BEE_TYPES.DRONE]: 'Drone'
            };
            const typeColors = {
                [BEE_TYPES.FORAGER]: 'bee-forager',
                [BEE_TYPES.BUILDER]: 'bee-builder',
                [BEE_TYPES.NURSE]: 'bee-nurse',
                [BEE_TYPES.SCOUT]: 'bee-forager', // Use forager color for scouts
                [BEE_TYPES.DRONE]: 'bee-builder' // Use builder color for drones
            };
            
            const bee = trackedBee;
            const distanceToTarget = bee.targetCell ? 
                Math.sqrt(Math.pow(bee.targetCell.x - bee.x, 2) + Math.pow(bee.targetCell.y - bee.y, 2)) : 0;
            
            const beeContent = `
                <div class="tracked-bee-stats-grid">
                    ${bee.name ? `
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Name</span>
                            <span class="tracked-stat-value" style="font-weight: bold; color: #667eea;">${bee.name}</span>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Type</span>
                            <span class="tracked-stat-value">
                                <span class="bee-type-badge ${typeColors[bee.type]}">${typeNames[bee.type]}</span>
                            </span>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">State</span>
                            <span class="tracked-stat-value">${bee.state}</span>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Carrying</span>
                            <span class="tracked-stat-value">${bee.carrying ? 'Nectar/Pollen' : 'Empty'}</span>
                        </div>
                        ${bee.carrying ? `
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill honey" style="width: 100%"></div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Speed</span>
                            <span class="tracked-stat-value">${bee.speed.toFixed(2)}</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill" style="width: ${(bee.speed / 5) * 100}%"></div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Efficiency</span>
                            <span class="tracked-stat-value">${(bee.efficiency * 100).toFixed(0)}%</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill efficiency" style="width: ${bee.efficiency * 100}%"></div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Position</span>
                            <span class="tracked-stat-value">(${Math.round(bee.x)}, ${Math.round(bee.y)})</span>
                        </div>
                    </div>
                    
                    ${bee.targetCell ? `
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Target Distance</span>
                            <span class="tracked-stat-value">${Math.round(distanceToTarget)}px</span>
                        </div>
                        <div class="tracked-stat-bar">
                            <div class="tracked-stat-bar-fill" style="width: ${Math.min(100, (1 - distanceToTarget / 200) * 100)}%"></div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Target Cell</span>
                            <span class="tracked-stat-value">(${bee.targetCell.q}, ${bee.targetCell.r})</span>
                        </div>
                    </div>
                    ` : `
                    <div>
                        <div class="tracked-stat-item">
                            <span class="tracked-stat-label">Status</span>
                            <span class="tracked-stat-value" style="color: #999;">Exploring</span>
                        </div>
                    </div>
                    `}
                </div>
            `;
            
            trackedBeeContent.innerHTML = beeContent;
        }
        
        // Event listeners
        document.getElementById('colonySize').addEventListener('input', (e) => {
            config.colonySize = parseInt(e.target.value);
            document.getElementById('colonySizeValue').textContent = config.colonySize;
            
            // Adjust bee count with proper specialization
            while (bees.length < config.colonySize) {
                const rand = Math.random();
                let beeType;
                if (rand < 0.35) {
                    beeType = BEE_TYPES.FORAGER;
                } else if (rand < 0.65) {
                    beeType = BEE_TYPES.BUILDER;
                } else if (rand < 0.85) {
                    beeType = BEE_TYPES.NURSE;
                } else if (rand < 0.92) {
                    beeType = BEE_TYPES.SCOUT;
                } else {
                    beeType = BEE_TYPES.DRONE;
                }
                
                bees.push({
                    x: config.centerX + (Math.random() - 0.5) * 100,
                    y: config.centerY + (Math.random() - 0.5) * 100,
                    targetCell: null,
                    speed: beeType === BEE_TYPES.FORAGER ? 3 + Math.random() * 2 : 
                           beeType === BEE_TYPES.SCOUT ? 4 + Math.random() * 2 : 
                           beeType === BEE_TYPES.DRONE ? 1.5 + Math.random() : 
                           2 + Math.random() * 2,
                    carrying: false,
                    angle: Math.random() * Math.PI * 2,
                    state: 'exploring',
                    type: beeType,
                    efficiency: beeType === BEE_TYPES.FORAGER ? 1.2 : beeType === BEE_TYPES.BUILDER ? 1.1 : 1.0,
                    name: generateBeeName(beeType),
                    // Waggle dance properties
                    isDancing: false,
                    danceCountdown: 0,
                    discoveredResource: null,
                    // Scout properties
                    scoutingTarget: null,
                    // Drone properties
                    wanderAngle: Math.random() * Math.PI * 2
                });
            }
            while (bees.length > config.colonySize) {
                bees.pop();
            }
        });
        
        document.getElementById('resourceAvailability').addEventListener('input', (e) => {
            config.resourceAvailability = parseInt(e.target.value);
            document.getElementById('resourceValue').textContent = config.resourceAvailability;
        });
        
        // Bee naming controls
        document.getElementById('beeNamingEnabled').addEventListener('change', (e) => {
            config.beeNaming.enabled = e.target.checked;
            // Regenerate names for all existing bees
            if (config.beeNaming.enabled) {
                bees.forEach(bee => {
                    bee.name = generateBeeName(bee.type);
                });
                if (queenBee) {
                    queenBee.name = generateBeeName(BEE_TYPES.QUEEN);
                }
            } else {
                bees.forEach(bee => {
                    bee.name = null;
                });
                if (queenBee) {
                    queenBee.name = null;
                }
            }
            updateAllTrackedStats();
        });
        
        document.getElementById('beeNamingFormat').addEventListener('change', (e) => {
            config.beeNaming.format = e.target.value;
            // Regenerate names for all existing bees
            if (config.beeNaming.enabled) {
                bees.forEach(bee => {
                    bee.name = generateBeeName(bee.type);
                });
                if (queenBee) {
                    queenBee.name = generateBeeName(BEE_TYPES.QUEEN);
                }
            }
            updateAllTrackedStats();
        });
        
        document.getElementById('hiveSize').addEventListener('input', (e) => {
            const newMaxRings = parseInt(e.target.value);
            document.getElementById('hiveSizeValue').textContent = newMaxRings;
            
            if (newMaxRings > config.maxRings) {
                // Add new rings without disrupting existing cells
                for (let ring = config.maxRings + 1; ring <= newMaxRings; ring++) {
                    const hexagons = getHexRing(0, 0, ring);
                    hexagons.forEach(hex => {
                        const pos = hexToPixel(hex.q, hex.r);
                        cells.push({
                            q: hex.q,
                            r: hex.r,
                            x: pos.x,
                            y: pos.y,
                            type: CELL_TYPES.EMPTY,
                            honeyLevel: 0,
                            buildProgress: 0,
                            age: 0,
                            transitionProgress: 1,
                            previousType: CELL_TYPES.EMPTY
                        });
                    });
                }
            } else if (newMaxRings < config.maxRings) {
                // Remove cells beyond the new max ring
                const maxDistance = newMaxRings + 0.5;
                for (let i = cells.length - 1; i >= 0; i--) {
                    const distance = Math.sqrt(cells[i].q * cells[i].q + cells[i].r * cells[i].r + cells[i].q * cells[i].r);
                    if (distance > maxDistance) {
                        // Clear any bees targeting this cell
                        bees.forEach(bee => {
                            if (bee.targetCell === cells[i]) {
                                bee.targetCell = null;
                            }
                        });
                        cells.splice(i, 1);
                    }
                }
            }
            
            config.maxRings = newMaxRings;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            beeCounter = 0; // Reset bee counter
            initializeGrid();
            initializeQueen();
            initializeBees();
            trackedBee = null;
            trackedCell = null;
            updateAllTrackedStats();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            config.isPaused = !config.isPaused;
            e.target.textContent = config.isPaused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('simulationSpeed').addEventListener('input', (e) => {
            config.simulationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = config.simulationSpeed.toFixed(2);
        });
        
        document.getElementById('clearTrackingBtn').addEventListener('click', () => {
            trackedBee = null;
            trackedCell = null;
            updateAllTrackedStats(); // Update stats panels
        });
        
        // Mouse move for tooltips
        canvas.addEventListener('mousemove', (e) => {
            const cell = getCellAtPosition(e.clientX, e.clientY);
            const bee = getBeeAtPosition(e.clientX, e.clientY);
            
            if (bee) {
                const typeNames = {
                    [BEE_TYPES.FORAGER]: 'Forager',
                    [BEE_TYPES.BUILDER]: 'Builder',
                    [BEE_TYPES.NURSE]: 'Nurse',
                    [BEE_TYPES.SCOUT]: 'Scout',
                    [BEE_TYPES.DRONE]: 'Drone'
                };
                const typeColors = {
                    [BEE_TYPES.FORAGER]: 'bee-forager',
                    [BEE_TYPES.BUILDER]: 'bee-builder',
                    [BEE_TYPES.NURSE]: 'bee-nurse',
                    [BEE_TYPES.SCOUT]: 'bee-forager',
                    [BEE_TYPES.DRONE]: 'bee-builder'
                };
                
                const beeTypeLabel = bee.type === BEE_TYPES.DRONE ? 'üêù Drone Bee' : 
                                     bee.type === BEE_TYPES.SCOUT ? 'üîç Scout Bee' : 
                                     'üêù Worker Bee';
                const content = `
                    <div class="tooltip-title">${beeTypeLabel} 
                        <span class="bee-type-badge ${typeColors[bee.type]}">${typeNames[bee.type]}</span>
                    </div>
                    ${bee.name ? `<div class="tooltip-item" style="font-weight: bold; color: #667eea;">Name: ${bee.name}</div>` : ''}
                    <div class="tooltip-item">State: ${bee.state}${bee.isDancing ? ' (Dancing!)' : ''}</div>
                    ${bee.type !== BEE_TYPES.DRONE ? `<div class="tooltip-item">Carrying: ${bee.carrying ? 'Nectar/Pollen' : 'Empty'}</div>` : ''}
                    <div class="tooltip-item">Speed: ${bee.speed.toFixed(2)}</div>
                    ${bee.type !== BEE_TYPES.DRONE ? `<div class="tooltip-item">Efficiency: ${(bee.efficiency * 100).toFixed(0)}%</div>` : ''}
                    ${bee.type === BEE_TYPES.SCOUT ? `<div class="tooltip-item" style="color: #4169E1;">üîç Exploring for expansion areas</div>` : ''}
                    ${bee.type === BEE_TYPES.DRONE ? `<div class="tooltip-item" style="color: #8B4513;">Wandering (non-worker)</div>` : ''}
                    <div class="tooltip-item">Position: (${Math.round(bee.x)}, ${Math.round(bee.y)})</div>
                    <div class="tooltip-item" style="margin-top: 5px; font-style: italic;">
                        ${bee === trackedBee ? '‚úÖ Currently tracked ‚Ä¢ Click another bee to switch' : 'Click to track'}
                    </div>
                `;
                showTooltip(e.clientX, e.clientY, content);
            } else if (cell && cell.buildProgress > 0) {
                let lifecycleInfo = '';
                if (cell.lifecycleStage) {
                    const stageNames = {
                        [LIFECYCLE_STAGES.EGG]: 'Egg',
                        [LIFECYCLE_STAGES.LARVA]: 'Larva',
                        [LIFECYCLE_STAGES.PUPA]: 'Pupa'
                    };
                    lifecycleInfo = `
                        <div class="tooltip-item">Lifecycle: ${stageNames[cell.lifecycleStage]}</div>
                        <div class="tooltip-item">Progress: ${(cell.lifecycleProgress * 100).toFixed(0)}%</div>
                        ${cell.royalJelly ? '<div class="tooltip-item" style="color: #FFD700;">‚ú® Royal Jelly</div>' : ''}
                    `;
                }
                
                const content = `
                    <div class="tooltip-title">üî∑ Hexagonal Cell</div>
                    <div class="tooltip-item">Type: ${cell.type}</div>
                    ${lifecycleInfo}
                    <div class="tooltip-item">Build Progress: ${(cell.buildProgress * 100).toFixed(0)}%</div>
                    <div class="tooltip-item">Honey Level: ${(cell.honeyLevel * 100).toFixed(0)}%</div>
                    <div class="tooltip-item">Age: ${Math.round(cell.age)} frames</div>
                    <div class="tooltip-item">Coordinates: (${cell.q}, ${cell.r})</div>
                    <div class="tooltip-item" style="margin-top: 5px; font-style: italic;">
                        ${cell === trackedCell ? '‚úÖ Currently tracked ‚Ä¢ Click another cell to switch' : 'Click to track'}
                    </div>
                `;
                showTooltip(e.clientX, e.clientY, content);
            } else if (queenBee) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const dx = canvasX - queenBee.x;
                const dy = canvasY - queenBee.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 15) {
                    const content = `
                        <div class="tooltip-title">üëë Queen Bee</div>
                        ${queenBee.name ? `<div class="tooltip-item" style="font-weight: bold; color: #FFD700;">Name: ${queenBee.name}</div>` : ''}
                        <div class="tooltip-item">State: ${queenBee.state}</div>
                        <div class="tooltip-item">Eggs Laid: ${queenBee.eggsLaid}</div>
                        <div class="tooltip-item">Royal Jelly Produced: ${queenBee.royalJellyProduction}</div>
                        <div class="tooltip-item">Position: (${Math.round(queenBee.x)}, ${Math.round(queenBee.y)})</div>
                    `;
                    showTooltip(e.clientX, e.clientY, content);
                } else {
                    hideTooltip();
                }
            } else {
                hideTooltip();
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            hideTooltip();
        });
        
        // Click to track bee or cell (works even when paused)
        canvas.addEventListener('click', (e) => {
            const bee = getBeeAtPosition(e.clientX, e.clientY);
            const cell = getCellAtPosition(e.clientX, e.clientY);
            
            if (bee) {
                trackedBee = bee;
                // Don't clear cell tracking - both can be tracked simultaneously
                updateAllTrackedStats(); // Update stats panels immediately
                // Show confirmation tooltip briefly
                const typeNamesMap = {
                    [BEE_TYPES.FORAGER]: 'Forager',
                    [BEE_TYPES.BUILDER]: 'Builder',
                    [BEE_TYPES.NURSE]: 'Nurse',
                    [BEE_TYPES.SCOUT]: 'Scout',
                    [BEE_TYPES.DRONE]: 'Drone'
                };
                const content = `
                    <div class="tooltip-title">‚úÖ Tracking ${typeNamesMap[bee.type] || bee.type}</div>
                    <div class="tooltip-item">Stats shown in side panel</div>
                `;
                showTooltip(e.clientX, e.clientY, content);
                setTimeout(() => {
                    // Restore normal tooltip after 1 second
                    const currentBee = getBeeAtPosition(e.clientX, e.clientY);
                    if (currentBee === bee) {
                        const typeNames = {
                            [BEE_TYPES.FORAGER]: 'Forager',
                            [BEE_TYPES.BUILDER]: 'Builder',
                            [BEE_TYPES.NURSE]: 'Nurse'
                        };
                        const typeColors = {
                            [BEE_TYPES.FORAGER]: 'bee-forager',
                            [BEE_TYPES.BUILDER]: 'bee-builder',
                            [BEE_TYPES.NURSE]: 'bee-nurse'
                        };
                        
                        const normalContent = `
                            <div class="tooltip-title">üêù Worker Bee 
                                <span class="bee-type-badge ${typeColors[bee.type]}">${typeNames[bee.type]}</span>
                            </div>
                            <div class="tooltip-item">State: ${bee.state}</div>
                            <div class="tooltip-item">Carrying: ${bee.carrying ? 'Nectar/Pollen' : 'Empty'}</div>
                            <div class="tooltip-item">Speed: ${bee.speed.toFixed(2)}</div>
                            <div class="tooltip-item">Efficiency: ${(bee.efficiency * 100).toFixed(0)}%</div>
                            <div class="tooltip-item">Position: (${Math.round(bee.x)}, ${Math.round(bee.y)})</div>
                            <div class="tooltip-item" style="margin-top: 5px; font-style: italic;">Click to track ‚Ä¢ Currently tracked</div>
                        `;
                        showTooltip(e.clientX, e.clientY, normalContent);
                    }
                }, 1000);
            } else if (cell && cell.buildProgress > 0) {
                trackedCell = cell;
                // Don't clear bee tracking - both can be tracked simultaneously
                updateAllTrackedStats(); // Update stats panels immediately
                // Show confirmation tooltip briefly
                const lifecycleInfo = cell.lifecycleStage ? ` (${cell.lifecycleStage})` : '';
                const content = `
                    <div class="tooltip-title">‚úÖ Tracking Cell${lifecycleInfo}</div>
                    <div class="tooltip-item">Stats shown in side panel</div>
                `;
                showTooltip(e.clientX, e.clientY, content);
                setTimeout(() => {
                    // Restore normal tooltip after 1 second
                    const currentCell = getCellAtPosition(e.clientX, e.clientY);
                    if (currentCell === cell) {
                        let lifecycleInfo = '';
                        if (cell.lifecycleStage) {
                            const stageNames = {
                                [LIFECYCLE_STAGES.EGG]: 'Egg',
                                [LIFECYCLE_STAGES.LARVA]: 'Larva',
                                [LIFECYCLE_STAGES.PUPA]: 'Pupa'
                            };
                            lifecycleInfo = `
                                <div class="tooltip-item">Lifecycle: ${stageNames[cell.lifecycleStage]}</div>
                                <div class="tooltip-item">Progress: ${(cell.lifecycleProgress * 100).toFixed(0)}%</div>
                                ${cell.royalJelly ? '<div class="tooltip-item" style="color: #FFD700;">‚ú® Royal Jelly</div>' : ''}
                            `;
                        }
                        
                        const normalContent = `
                            <div class="tooltip-title">üî∑ Hexagonal Cell</div>
                            <div class="tooltip-item">Type: ${cell.type}</div>
                            ${lifecycleInfo}
                            <div class="tooltip-item">Build Progress: ${(cell.buildProgress * 100).toFixed(0)}%</div>
                            <div class="tooltip-item">Honey Level: ${(cell.honeyLevel * 100).toFixed(0)}%</div>
                            <div class="tooltip-item">Age: ${Math.round(cell.age)} frames</div>
                            <div class="tooltip-item">Coordinates: (${cell.q}, ${cell.r})</div>
                            <div class="tooltip-item" style="margin-top: 5px; font-style: italic;">Click to track ‚Ä¢ Currently tracked</div>
                        `;
                        showTooltip(e.clientX, e.clientY, normalContent);
                    }
                }, 1000);
            } else {
                // Clicked on empty space - clear tracking
                trackedBee = null;
                trackedCell = null;
                updateAllTrackedStats(); // Update stats panels
            }
        });
        
        // Initialize and start
        // Initialize UI controls to match config
        document.getElementById('beeNamingEnabled').checked = config.beeNaming.enabled;
        document.getElementById('beeNamingFormat').value = config.beeNaming.format;
        
        initializeGrid();
        initializeQueen();
        initializeBees();
        updateChart(); // Initialize chart
        animate();
    </script>
</body>
</html>
